// tslint:disable
{{>licenseInfo}}

import * as url                                 	    from "url";
import * as isomorphicFetch                     	    from "isomorphic-fetch";
import { Configuration }                                from "./configuration";

const BASE_PATH = "{{{basePath}}}".replace(/\/+$/, "");

/**
 *
 * @export
 * @interface FetchAPI
 */
export interface FetchAPI {
    (url: string, init?: any): Promise<any>;
}

/**
 *  
 * @export
 * @interface FetchArgs
 */
export interface FetchArgs {
    url: string;
    options: any;
}

/**
 * 
 * @export
 * @class BaseAPI
 */
export class BaseAPI {
    public config: Configuration = new Configuration();

    constructor(config?: Configuration, protected basePath: string = BASE_PATH, protected fetch: FetchAPI = isomorphicFetch) {
        if (config) {
            this.config = config;
            this.basePath = config.basePath || this.basePath;
        }
    }
};

/**
 * 
 * @export
 * @class RequiredError
 * @extends {Error}
 */
export class RequiredError extends Error {
    name: "RequiredError"
    constructor(public field: string, msg?: string) {
        super(msg);
    }
}
{{#models}}
{{#model}}
{{#isEnum}}{{>modelEnum}}{{/isEnum}}
{{^isEnum}}{{>modelGeneric}}{{/isEnum}}
{{/model}}
{{/models}}
{{#apiInfo}}
{{#apis}}
{{#operations}}
/**
 * {{classname}} - fetch parameter creator{{#description}}
 * {{&description}}{{/description}}
 */
export const {{classname}}FetchParamCreator = function (config?: Configuration) {
    return {
    {{#operation}}
        /**
         * {{&notes}}
         {{#summary}}
         * @summary {{&summary}}
         {{/summary}}
         {{#allParams}}
         * @param {{=<% %>=}}{<%dataType%>}<%={{ }}=%> {{^required}}[{{/required}}{{paramName}}{{^required}}]{{/required}} {{description}}
         {{/allParams}}
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        {{nickname}}({{#allParams}}{{paramName}}{{^required}}?{{/required}}: {{{dataType}}}, {{/allParams}}options: any = {}): FetchArgs {
    {{#allParams}}
    {{#required}}
            // verify required parameter '{{paramName}}' is not null or undefined
            if ({{paramName}} === null || {{paramName}} === undefined) {
                throw new RequiredError('{{paramName}}','Required parameter {{paramName}} was null or undefined when calling {{nickname}}.');
            }
    {{/required}}
    {{/allParams}}
            const path = `{{{path}}}`{{#pathParams}}
                .replace(`{${"{{baseName}}"}}`, String({{paramName}})){{/pathParams}};
            const urlObj = url.parse(path, true);
            const requestOptions = Object.assign({ method: '{{httpMethod}}' }, options);
            const headerOptions = {} as any;
            const queryParameter = {} as any;
    {{#hasFormParams}}
            const formParams = new url.URLSearchParams();
    {{/hasFormParams}}

    {{#authMethods}}
            // authentication {{name}} required
            {{#isApiKey}}
            {{#isKeyInHeader}}
            if (config && config.apiKey && config.apiKey.{{keyParamName}}) {
                headerOptions["{{keyParamName}}"] = config.apiKey.{{keyParamName}};
            }
            {{/isKeyInHeader}}
            {{#isKeyInQuery}}
            if (config && config.apiKey && config.apiKey.{{keyParamName}}) {
                queryParameter["{{keyParamName}}"] = config.apiKey.{{keyParamName}};
            }
            {{/isKeyInQuery}}
            {{/isApiKey}}
            {{#isBasic}}
            // http basic authentication required
            if (config && (config.username || config.password)) {
                headerOptions["Authorization"] = "Basic " + btoa(config.username + ":" + config.password);
            }
            {{/isBasic}}
            {{#isOAuth}}
            // oauth required
            if (config && config.accessToken) {
				const accessToken = typeof config.accessToken === 'function'
					? config.accessToken("{{name}}")
					: config.accessToken;
                headerOptions["Authorization"] = "Bearer " + config.accessToken;
            }
            {{/isOAuth}}

    {{/authMethods}}
    {{#queryParams}}
            {{#isListContainer}}
            if ({{paramName}}) {
            {{#isCollectionFormatMulti}}
                queryParameter['{{baseName}}'] = {{paramName}} as any;
            {{/isCollectionFormatMulti}}
            {{^isCollectionFormatMulti}}
                queryParameter['{{baseName}}'] = {{paramName}}.join(',');
            {{/isCollectionFormatMulti}}
            }
            {{/isListContainer}}
            {{^isListContainer}}
            if ({{paramName}} !== undefined) {
                {{#isDateTime}}
                queryParameter['{{baseName}}'] = ({{paramName}} as any).toISOString();
                {{/isDateTime}}
                {{^isDateTime}}
                {{#isDate}}
                queryParameter['{{baseName}}'] = ({{paramName}} as any).toISOString();
                {{/isDate}}
                {{^isDate}}
                queryParameter['{{baseName}}'] = {{paramName}} as any;
                {{/isDate}}
                {{/isDateTime}}
            }
            {{/isListContainer}}

    {{/queryParams}}
    {{#headerParams}}
            {{#isListContainer}}
            if ({{paramName}}) {
                headerOptions['{{baseName}}'] = {{paramName}}.join(',');
            }
            {{/isListContainer}}
            {{^isListContainer}}
            if ({{paramName}} !== undefined && {{paramName}} !== null) {
                headerOptions['{{baseName}}'] = String({{paramName}});
            }
            {{/isListContainer}}

    {{/headerParams}}
    {{#formParams}}
            {{#isListContainer}}
            if ({{paramName}}) {
            {{#isCollectionFormatMulti}}
                {{paramName}}.forEach((element) => {
                    formParams.append('{{baseName}}', <any>element);
                })
            {{/isCollectionFormatMulti}}
            {{^isCollectionFormatMulti}}
                    formParams.set('{{baseName}}', {{paramName}}.join(','));
            {{/isCollectionFormatMulti}}
            }
            {{/isListContainer}}
            {{^isListContainer}}
            if ({{paramName}} !== undefined) {
                formParams.set('{{baseName}}', <any>{{paramName}});
            }
            {{/isListContainer}}

    {{/formParams}}
    {{#hasFormParams}}
            headerOptions['Content-Type'] = 'application/x-www-form-urlencoded';

    {{/hasFormParams}}
    {{#bodyParam}}
            headerOptions['Content-Type'] = 'application/json';

    {{/bodyParam}}
            urlObj.query = Object.assign({}, urlObj.query, queryParameter, options.query);
            requestOptions.headers = Object.assign({}, headerOptions, options.headers);
    {{#hasFormParams}}
            requestOptions.body = formParams.toString();
    {{/hasFormParams}}
    {{#bodyParam}}
            requestOptions.body = JSON.stringify({{paramName}} || {});
    {{/bodyParam}}

            return {
                url: url.format(urlObj),
                options: requestOptions,
            };
        },
    {{/operation}}
    }
};

/**
 * {{classname}} - functional programming interface{{#description}}
 * {{{description}}}{{/description}}
 */
export const {{classname}}Fp = function(config?: Configuration) {
    return {
    {{#operation}}
        /**
         * {{&notes}}
         {{#summary}}
         * @summary {{&summary}}
         {{/summary}}
         {{#allParams}}
         * @param {{=<% %>=}}{<%dataType%>}<%={{ }}=%> {{^required}}[{{/required}}{{paramName}}{{^required}}]{{/required}} {{description}}
         {{/allParams}}
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        {{nickname}}({{#allParams}}{{paramName}}{{^required}}?{{/required}}: {{{dataType}}}, {{/allParams}}options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<{{#returnType}}{{{returnType}}}{{/returnType}}{{^returnType}}any{{/returnType}}> {
            const fetchArgs = {{classname}}FetchParamCreator(config).{{nickname}}({{#allParams}}{{paramName}}, {{/allParams}}options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + fetchArgs.url, fetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response{{#returnType}}.json(){{/returnType}};
                    } else {
                        throw response;
                    }
                });
            };
        },
    {{/operation}}
    }
};

/**
 * {{classname}} - factory interface{{#description}}
 * {{&description}}{{/description}}
 */
export const {{classname}}Factory = function (config?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
{{#operation}}
        /**
         * {{&notes}}
         {{#summary}}
         * @summary {{&summary}}
         {{/summary}}
         {{#allParams}}
         * @param {{=<% %>=}}{<%dataType%>}<%={{ }}=%> {{^required}}[{{/required}}{{paramName}}{{^required}}]{{/required}} {{description}}
         {{/allParams}}
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        {{nickname}}({{#allParams}}{{paramName}}{{^required}}?{{/required}}: {{{dataType}}}, {{/allParams}}options?: any) {
            return {{classname}}Fp(config).{{nickname}}({{#allParams}}{{paramName}}, {{/allParams}}options)(fetch, basePath);
        },
{{/operation}}
    };
};

/**
 * {{classname}} - object-oriented interface{{#description}}
 * {{{description}}}{{/description}}
 * @export
 * @class {{classname}}
 * @extends {BaseAPI}
 */
export class {{classname}} extends BaseAPI {
{{#operation}}
    /**
     * {{&notes}}
     {{#summary}}
     * @summary {{&summary}}
     {{/summary}}
     {{#allParams}}
     * @param {{=<% %>=}}{<%%dataType%%>}<%={{ }}=%> {{^required}}[{{/required}}{{paramName}}{{^required}}]{{/required}} {{description}}
     {{/allParams}}
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof {{classname}}
     */
    public {{nickname}}({{#allParams}}{{paramName}}{{^required}}?{{/required}}: {{{dataType}}}, {{/allParams}}options?: any) {
        return {{classname}}Fp(this.config).{{nickname}}({{#allParams}}{{paramName}}, {{/allParams}}options)(this.fetch, this.basePath);
    }
{{/operation}}
}

{{/operations}}
{{/apis}}
{{/apiInfo}}